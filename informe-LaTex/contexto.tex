\parte{Contexto}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sobre la materia \orga}


Si bien los conceptos fundamentales de la ejecución de programas son independientes de las arquitecturas de computadoras comerciales, es conveniente explicar los mismos dando un marco específico. Por otro lado, las diferentes arquitecturas que subyacen los numerosos modelos de computadoras disponibles en el mercado, incluyen un basto conjunto de herramientas y recursos de lenguaje para el control del funcionamiento de una computadora, pero que agregan complejidad innecesaria a la comprensión de los conceptos funcionales y la didáctica de la asignatura \orga.\\

La propuesta de la asignatura \orga\ es utilizar la arquitectura \Q, una arquitectura \textit{assembly-like} teórica (esto es, que no existe una computadora real que la implemente) basada en el modelo de ejecución de Von Neumann y cuya característica principal es la de ser minimalista y presentarse en 'capas'. Este enfoque permite ir incorporando los conceptos de manera gradual a partir de versiones escalonadas de la arquitectura, denominadas $Q_1$, $Q_2$, $Q_3$, $Q_4$, $Q_5$ y  $Q_6$.\\


Actualmente, la arquitectura se presenta a los estudiantes mediante especificaciones formales que deben analizar y comprender para utilizar el lenguaje de programación y resolver los problemas que se les plantean en la práctica. Entendemos que les resulta de gran utilidad incorporar una herramienta digital que les permita probar sus ejercicios de una manera automatizada y es por eso que se desarrolló un simulador para esta arquitectura.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conceptos importantes}

\subsection{Enfoque de Von Neumann}

El matemático John Von Neumann en el año 1945 se encontraba colaborando en el proyecto ENIAC (\textit{Electronic Numerical Integrator And Computer}), primer computadora electrónica de propósito general, diseñada para ser utilizada por el ejército norteamericano. La ENIAC podía ser programada para realizar operaciones complejas e incluso decisiones, interacciones y subrutinas, pero la tarea de resolver un problema y volcarlo en la máquina era tan complejo que podía tomar semanas. Luego que el programa era diseñado en papel, el proceso de representarlo en la máquina ENIAC mediante la manipulación de cables e interruptores tomaba varios días. Entonces Von Neumann se comenzó a interesar por la problemática que significaba la necesidad de reconfigurar la máquina para cada nueva tarea y tan sólo cuatro años más tarde propone y desarrolla una solución a este problema que se basaba en almacenar la información sobre las operaciones a realizar en la misma memoria utilizada para los datos, a partir de su codificación en código binario.\\

Este enfoque generaliza la organización de las computadoras distinguiendo en tres partes interconectadas: La CPU (con la unidad aritmético-lógica o ALU y la unidad de control) la memoria, y un módulo de entrada/salida. La interconexión es llevada a cabo por un bus de sistema que proporciona un medio de transporte de los datos entre las distintas partes. \\

Con la propuesta de este modelo, Von Neumann incorpora el concepto de \textbf{programa almacenado} en memoria. Con esta idea, el programa se codifica de cierta manera para que pueda ser almacenado en memoria principal y posteriormente pueda ser ejecutado, quizás múltiples veces. De esta manera, la lógica del programa puede ser ''recordada'' y el programa toma un valor mayor, a diferencia de lo que ocurría hasta entonces, donde el programa se reflejaba en un conjunto de configuraciones de cables aplicadas a los equipos. Esto implica una separación entre el mecanismo de ejecución (el \textit{hardware}) y la lógica de computo o instrucciones (el \textit{software}). La codificación en binario de las instrucciones de un programa se denomina \textbf{\codmaq}.\\

Por otro lado este tipo de diseño, que permite un programa almacenado, también da la posibilidad de que la ejecución de las instrucciones modifique el código máquina del mismo u otro programa. Por ejemplo un programa podría modificar o incrementar las referencias a las direcciones de memoria que tenga en algunas instrucciones y luego volver a ejecutar dichas instrucciones con el fin de procesar celdas diferentes de memoria cada vez. Esta característica es potente pero a la vez presenta un alto riesgo pues las modificaciones en los programas, hechas por programas, podría ser algo perjudicial, por accidente o por diseño.

\subsection{Organización de la computadora}

La CPU (Unidad Central de Procesamiento del inglés: \textit{Central Processing Unit}), es el componente principal y el encargado ejecutar los programas y procesar los datos. La CPU contiene otros componentes de importancia tales como la \UC, algunos registros de uso específico como el contador de programa (PC - \textit{Program Counter}), el registro de instrucción (IR - \textit{Instruction Register}) y el puntero de pila (SP - \textit{Stack pointer}), además de otros registros de uso general y la Unidad Aritmético-Lógica (ALU).\\

La \UC\ dirige el ciclo de ejecución de cada instrucción, pidiendo la lectura de celdas de memoria donde esta alojada, decodificándola  y ejecutándola luego en colaboración con los otros componentes del sistema: si es una operación lógica o aritmética le ordena a la ALU su ejecución, si es de movimiento de datos colabora con la memoria ó el módulo de Entrada/Salida.\\

Entre los registros de uso específico, los más importantes son el \textbf{\PC}, el \textbf{\IR}, el \textbf{\SP} y el \textbf{\flagreg}. El \PC\ es un registro que indica la posición de memoria donde estará la siguiente instrucción que debe ejecutarse. Luego de completar el ciclo de ejecución de una instrucción, el PC se incrementa en función de la cantidad de celdas que ocupa el código máquina de esta. El \IR contiene el código máquina de la instrucción actual una vez que la misma es leída de memoria para luego decodificarla y ejecutarla.\\

El \SP\ lleva registro del primer lugar libre en la pila de sistema. Esta pila es una estructura de datos que se utiliza para mantener las direcciones de retorno de las subrutinas. Es decir que al momento de invocar una subrutina se agrega en el tope de la pila la dirección de la instrucción (dirección de retorno) que sigue a dicha invocación, de manera que al finalizar la ejecución de la subrutina pueda continuarse la ejecución del programa que la llamó. Los \textit{flags} agrupados en el \flagreg\ representan características del último computo realizado, como por ejemplo: si el resultado fue negativo, cero, o un desborde.\\

El diseño de cada arquitectura ofrece un conjunto diferente de registros de uso general para ser usados en los programas. Estos registros son elementos de memoria de alta velocidad y poca capacidad que pueden ser utilizados como variables en los programas. Es importante marcar que pueden almacenar tanto datos como direcciones de memoria.\\

La \textbf{ALU} recibe su nombre de las siglas en inglés de \textit{Arithmetic and Logic Unit}. La ALU es un circuito digital que lleva a cabo operaciones aritméticas (suma, resta, multiplicación, división) y las operaciones lógicas como la negación, disyunción, conjunción, etc, entre dos cadenas binarias que son interpretadas como números o valores lógicos.\\

La memoria es un conjunto de celdas numeradas. La numeración de cada celda la identifica inequívocamente por lo cual a esta numeración se le llama dirección. En cada celda de la memoria se pueden almacenar datos o instrucciones en forma de cadenas binarias y este contenido puede leerse y modificarse. En la memoria es donde se alojan los programas que luego serán ejecutados.\\

El bus de sistema es el encargado de transferir los datos entre los componentes de la computadora. La unidad de control pide la lectura de una celda a través de la interacción con el bus de sistema, y similarmente cuando desea escribir en memoria. Tiene lineas de control, de datos y de direcciones que permiten a la UC enviar comandos, direcciones de puertos o celdas de memoria, y datos hacia o desde el módulo de entrada/salida o la memoria principal.

\subsection{Ejecución de un programa}

La función de una computadora es la ejecución de programas. Los programas se encuentran almacenados en memoria y consisten en una secuencia de instrucciones y es la \UC\ quien se encarga de ejecutar dichas instrucciones implementando un \textbf{\ciclo}. Para ser almacenadas en memoria, las instrucciones deben codificarse en cadenas binarias (secuencias de ceros y unos) que no son legibles para las personas pero son tales que la \UC\ las puede interpretar y traducir en acciones. Por eso para saber de qué instrucción se trata, y cuáles son los valores o variables (celdas de memoria o registros) que están involucrados, la \UC\ toma el código máquina de la instrucción y verifica los códigos de operación y modos de direccionamiento. La ejecución de instrucciones se divide en tres etapas importantes, ilustrados en la figura \ref{ciclo}: 

\begin{enumerate}
\item \BI
\item \DI
\item \EI
\end{enumerate}
\graf[7cm]{ciclo}{\ciclo}


Al principio de cada \ciclo\ se lleva a cabo la \BI\ durante la cual se leen las celdas que contienen el \codmaq\ de la instrucción y para lo cual se utiliza el \PC\ que mantiene la dirección de la siguiente instrucción a ejecutar.
El código máquina de la instrucción leída que está en la forma de cadena binaria se carga dentro de otro registro de la CPU, llamado registro de instrucción (IR).\\

Durante la \DI, la \UC\ determina que operación se debe llevar a cabo y con qué operandos, y finalmente durante la \EI\ la \UC\ realiza el efecto esperado para esa operación, buscando los operandos y modificando la memoria o los registros como resultado final, y el ciclo vuelve a comenzar.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Estado del arte}

A través de los años de la carrera \tpi, en la materia \orga\ se analizaron distintos enfoques y herramientas para desarrollar los conceptos relacionados a la ejecución de programas en una computadora.\\

Inicialmente se utilizó un simulador de código abierto para la arquitectura Intel 8085, que ofrecía una funcionalidad bastante completa, pero una interfaz que no resultaba del todo intuitiva.
Este simulador se eligió por tratarse de un lenguaje ensamblador mas reducido, con un repertorio de instrucciones y modos de direccionamiento mas pequeño, que contaba con un entorno de prueba (el simulador propiamente dicho) para facilitar la didáctica de la programación en lenguaje ensamblador, pero posteriormente se entendió que las características de la arquitectura no eran las adecuadas para la enseñanza de los contenidos y se descartó.\\
 
Entonces el equipo docente eligió definir una arquitectura teórica que proveyera solamente lo necesario para cumplir con los objetivos de la materia e inspirados en un caso similar de la Universidad de Buenos Aires, se definió la arquitectura \textbf{QARQ}, muy similar a la que se presenta en el apéndice \ref{apendiceQ}\\


Posteriormente, el equipo docente propuso un cambio en la secuencia didáctica que requirió la división de la especificación de la arquitectura QARQ en varias partes, donde cada una recibe el nombre de \textbf{Arquitectura Qi} y agrega una nueva funcionalidad (instrucciones o modos de direccionamientos) a la versión anterior, construyendo una arquitectura en capas. Sin embargo todos los ejercicios de las arquitecturas Qi se siguen haciendo en papel. \\

Actualmente se busca incorporar el \textbf{Simulador \qsim} en la materia con el objetivo de que los alumnos puedan visualizar el funcionamiento de una computadora al mas mínimo detalle, a través de la ejercitación del \ciclo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Arquitecturas Q}

Las versiones de la arquitectura Q están pensadas para incorporar funcionalidades de manera que la curva de aprendizaje sea adecuada para los alumnos, siendo paulatina e incremental, es decir, cada arquitectura $Q_{i+1}$ agrega más funcionalidad (ya sean instrucciones nuevas o modos de direccionamiento) a la arquitectura  $Q_{i}$ anterior (ver figura \ref{ArquitecturasQ})

\graf[10cm]{ArquitecturasQ}{Organización en capas de la arquitectura \Q}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


