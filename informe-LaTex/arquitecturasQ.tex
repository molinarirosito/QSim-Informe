\section{Especificación de la arquitectura Q}\label{apendiceQ}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Características generales} 

La Arquitectura Q tiene 8 registros de uso general de 16 bits, denominados R0..R7, registros especiales de 16 bits tales como PC - \textit{Program counter}, SP\footnote{Comienza en la dirección FFEF.} - \textit{Stack Pointer} y los Flags de un bit como Negative, oVerflow, Carry, Zero. 

Por ultimo tiene una Memoria Principal con direcciones de 16 bit, donde el tamaño de cada celda también es de 16 bit. Entonces la memoria tiene un tamaño de 65536 celdas. \\ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Modos de direccionamiento}
Los siguientes son los modos de direccionamiento implementados en la Arquitectura \Q.
\begin{enumerate}

\item \textbf{Inmediato} Representa un operando que denota un valor constante. Es importante notar que este modo direccionamiento es admitido en el operando origen pero no el operando destino. La codificación de este modo se indica en la tabla \ref{tablamodos}.

Ejemplos:
\begin{itemize}
\item \textbf{0x0000} denota el modo de direccionamiento inmediato cuyo valor es cero.
\item \textbf{0x000F} denota el modo de direccionamiento inmediato cuyo valor es 15.
\end{itemize}


\item \textbf{Directo}
Con este modo de direccionamiento se denota un operando alojado en una dirección de memoria o de puertos. La codificación de este modo se indica en la tabla \ref{tablamodos}.

Ejemplos:
\begin{itemize}
\item \textbf{[0x0000]} denota un operando cuyo valor se encuentra en la celda de memoria cuya dirección es \textbf{0x0000}.
\item \textbf{[0x000F]} denota  un operando cuyo valor se encuentra en la celda de memoria cuya dirección es \textbf{0x000F}.
\end{itemize}


\item \textbf{Indirecto}
Con este modo de direccionamiento se denota un operando alojado en una celda de memoria cuya dirección está almacenada en otra celda de memoria. La codificación de este modo se indica en la tabla \ref{tablamodos}.

Ejemplos:
\begin{itemize}
\item \textbf{[[0x0000]]} denota un operando cuyo valor se encuentra en la celda de memoria cuya dirección esta guardada como dato en la celda de memoria cuya dirección es \textbf{0x0000}
\item \textbf{[[0x000F]]} denota un operando cuyo valor se encuentra en la celda de memoria cuya dirección esta guardada como dato en la celda de memoria cuya dirección es \textbf{0x000F}
\end{itemize}

\item \textbf{Registro} Con este modo de direccionamiento se denota un operando alojado en un registro de uso general (R0 a R7). La codificación de este modo se indica en la tabla \ref{tablamodos}.

Ejemplos:
\textbf{R0} denota un operando almacenado en el registro R0. 
\textbf{R7} denota un operando almacenado en el registro R7.

\item \textbf{Registro Indirecto} De manera similar al modo indirecto, con este modo de direccionamiento se denota un operando alojado en una celda de memoria cuya dirección está almacenada en el registro indicado. La codificación de este modo se indica en la tabla \ref{tablamodos}.


Ejemplos:
\textbf{[R0]} denota un operando almacenado en una celda de memoria cuya dirección está en el registro \textbf{R0}.
\textbf{[R7]} denota un operando almacenado en una celda de memoria cuya dirección está en el registro \textbf{R7}.

\end{enumerate}

\tabla{|l|l|l|}{
\textbf{Modo}       &  \textbf{Codificación}\\ \hline\hline
Inmediato   &  000000\\ \hline
Directo     &  001000\\ \hline
Indirecto   &  011000\\ \hline
Registro    &  100rrr\\ \hline
Registro indirecto &  110rrr\\ \hline
}{\label{tablamodos}Tabla de códigos de los modos de direccionamiento (Nota: rrr describe el número de registro)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Repertorio de instrucciones}
En esta sección se detalla cómo se construye el código máquina de las instrucciones de la arquitectura.\\

Todas las instrucciones alteran los flags excepto MOV, CALL, RET, JMP y los saltos condicionales. De las instrucciones que alteran los Flags, todas dejan C y V en 0 a excepción de ADD, SUB y CMP.  \\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Instrucciones de 2 operandos}

A continuación se muestra la codificación (formato) de las instrucciones de dos operandos:

\formatoinstr{|c|c|c|c|c|c|}{
Codigo de Operación  & \mdest{}& \msrc{}  & \dest{} & \src{}\\
(4b)     &   (6b)  &  (6b)   &  (16b)  &  (16b)} 


Las instrucciones de dos operandos descriptas a continuación son instrucciones aritméticas o lógicas donde se asume que el resultado de la operación se almacena en uno de los dos operandos de entrada, y por lo tanto se lo denomina \textbf{operando destino}.

\begin{enumerate}
\item  \mostrarinst{MUL destino, origen}{0000}\\
Esta instrucción describe la multiplicación entre los datos de los dos operandos. Esta operación es la única que cuyo resultado puede ser 32 bits, que son lo que ocuparía más de una celda de memoria en código binario, por lo que los primeros 16 bits, es decir, la primer mitad, es guardada en el registro \textbf{R7} y la segunda en el operando destino.
 
\item  \mostrarinst{ADD destino, origen}{0010}\\
Esta instrucción describe la suma entre los datos de los dos operandos. El resultado de la ejecución de la suma es guardado en el operando destino.

\item  \mostrarinst{SUB destino, origen}{0011}\\
Esta instrucción describe la resta entre los datos de los dos operandos. El resultado de la ejecución de dicha resta es guardado en el operando destino.

\item  \mostrarinst{DIV destino, origen}{0111}\\
Esta instrucción describe la división entre el dato en el operando destino como dividendo y el dato en el operando origen como divisor. El resultado de la ejecución de la división es guardado en el operando destino.

\item  \mostrarinst{MOV destino, origen}{0001}\\
Esta instrucción describe la copia de datos del dato alojado en el operando origen al operando destino. El resultado de la ejecución del MOV es el dato guardado en el operando origen ahora también guardado en el operando destino.

\item  \mostrarinst{AND destino, origen}{0100}\\
Esta instrucción describe la conjunción bit a bit entre los datos de los dos operandos. El resultado de la ejecución de esta operación es guardado en el operando destino.

\item  \mostrarinst{CMP destino, origen}{0110}\\
Esta instrucción describe la resta entre dos operandos, sin guardar el resultado. Su único efecto es la actualización de flags en la cpu.

\item  \mostrarinst{OR destino, origen}{0101}\\
Esta instrucción describe la disyunción bit a bit entre los datos de los dos operandos. El resultado de la ejecución de esta operación es guardado en el operando destino.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Instrucciones de 1 operando origen}

El formato de las instrucciones de un operando origen es el siguiente:\\

\formatoinstr{|c|c|c|c|}
{CodOp& Relleno&\msrc{}& Operando \src{}\\
(4b)     &   (000000)  &  (6b)   &  (16b) 
}

\begin{enumerate}
\item  \mostrarinst{CALL origen}{1011}\\
El efecto del CALL es guardar la dirección de memoria en la celda de la dirección que se encuentra guardada en el SP (Stack pointer) aumentar el SP y guardar en el PC (Program Counter) el dato que se encuentra guardado en el operando origen ya que describe el llamado a una subrutina que comienza en la celda de memoria cuya dirección esta guardada en el operando origen.

\item  \mostrarinst{JMP origen}{0110}\\
El efecto del JMP es cambiar el PC (Program Counter) por el dato que esta guardado en el operando origen ya que esta operación describe el salto a otra parte de la memoria para continuar con la ejecución del programa.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Instrucciones de 1 operando destino}

El formato de las instrucciones de un operando destino es el siguiente:\\

\formatoinstr{|c|c|c|c|}
{CodOp & \msrc{} & Relleno & Operando \src{}\\
(4b)   &   (6b)  & (000000)&  (16b) 
} 

\begin{enumerate}
\item  \mostrarinst{NOT destino}{1001}\\
Esta instrucción describe la operación lógica "negación" bit a bit en el datos del operando destino. El resultado de la ejecución de esta operación es guardado en la misma celda o registro de donde es leído el dato inicialmente.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Instrucciones sin operandos}

El formato de las instrucciones sin operandos es el siguiente:\\

\formatoinstr{|c|c|}{CodOp & Relleno \\  (4b) & (000000000000)}


\begin{enumerate}
\item  \mostrarinst{RET}{0110}
El efecto del ret es cambiar el pc por el dato que esta guardado en la celda de memoria que se encuentra en el SP (Stack pointer) y decrementar el SP ya que describe la finalización de la ejecución de una subrutina y la ejecución del resto del programa.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Instrucciones de salto condicional  (falta revisar Mara)}

El formato de las instrucciones de salto condicional es el siguiente:\\

\formatoinstr{|c|c|}{CodOp (8)&Desplazamiento(8)} donde los primeros cuatro bits del campo \code{CodOp} es la cadena \code{1111}. Si \textbf{al evaluar la condición de salto} el resultado es 1, se le suma al PC el valor del desplazamiento, representado en el sistema Complemento a 2 de 8 bits. En caso contrario la instrucción no hace nada.


El efecto de cualquier salto condicional es aumentar el PC (Program Counter) en la cantidad de celdas que indique el desplazamiento si sólo la condición que cada salto condicional tiene da como resultado 1, lo cual es interpretado como verdadero.

\begin{enumerate}
\item  \mostrarinst{JE desplazamiento}{0001}\\
La condición del salto es que el flag \textbf{Z} (Cero) sea 1, es decir la ultima operación matemática dió como resultado el número cero.

\item  \mostrarinst{JNE desplazamiento}{1001}\\
La condición del salto es que el flag \textbf{Z} (Cero) sea 0, es decir la ultima operación matemática no dió como resultado el número cero.

\item  \mostrarinst{JLE desplazamiento}{0010}\\
La condición del salto es el resultado de la siguiente operación lógica \textbf{Z OR ( N XOR V )}, es decir la ultima operación matemática es menor o igual con signo.

\item  \mostrarinst{JG desplazamiento}{1010}\\
La condición del salto es el resultado de la siguiente operación lógica \textbf{NOT (Z OR ( N XOR V ))}, es decir la ultima operación matemática es mayor con signo.

\item  \mostrarinst{JL desplazamiento}{0011}\\
La condición del salto es el resultado de la siguiente operación lógica \textbf{N XOR V}, es decir la ultima operación matemática es menor con signo.

\item  \mostrarinst{JGE desplazamiento}{1011}\\
La condición del salto es el resultado de la siguiente operación lógica \textbf{NOT (N XOR V)}, es decir la ultima operación matemática es mayor o igual con signo.

\item  \mostrarinst{JLEU desplazamiento}{0100}\\
La condición del salto es el resultado de la siguiente operación lógica \textbf{C OR Z}, es decir la ultima operación matemática es menor o igual sin signo.

\item  \mostrarinst{JGU desplazamiento}{1100}\\
La condición del salto es el resultado de la siguiente operación lógica \textbf{NOT (C OR Z)}, es decir la ultima operación matemática es mayor sin signo.

\item  \mostrarinst{JCS desplazamiento}{0101}\\
La condición del salto es que el flag \textbf{C} sea 1, es decir la ultima operación matemática es menor sin signo.

\item  \mostrarinst{JNEG desplazamiento}{0101}\\
La condición del salto es que el flag \textbf{N} sea 1, es decir si el último resultado de una operación dio negativo.

\item  \mostrarinst{JVS desplazamiento}{0111}\\
La condición del salto es que el flag \textbf{V} sea 1, es decir si el último resultado de una operación dio overflow.

\end{enumerate}