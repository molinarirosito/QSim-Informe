\part{Evaluación del desarrollo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%55
\section{Dificultades encontradas}

\subsection{Dificultades presentadas por el dominio}
Las dificultades del dominio estuvieron relacionadas a la comprensión no solamente del modelo de arquitectura Q si no también a su propósito didáctico, ya que el objetivo del simulador no es solamente la simulación de la arquitectura y la ejecución de programas, sino también el proveer a los alumnos la capacidad de ejercitar situaciones conceptualmente erróneas, por lo que se requería una comprensión didáctica del problema más allá de la especificación de las arquitecturas Q. 

\subsection{Dificultades de diseño}
En primera instancia se optó por implementar un modelo de objetos que utilizaba un objeto de la clase \textbf{Programa} a lo largo de toda la ejecución. Esto permitía evitar la lectura de la memoria principal para obtener las instrucciones a ejecutar, solicitando cada instrucción al objeto de la clase Programa, sobreviviendo así las distintas etapas una vez que fue creado por el \textit{parser}. Este enfoque evitaba la necesidad de un objeto que tuviera que interpretar el código máquina alojado en la memoria, evitaba la nueva creación de instancias de la clase \textbf{Instrucción} y simplificaba en gran medida el modelo ya que la memoria era sólo una clase que contenía datos que se reflejaban en pantalla y no se la utilizaba en el la búsqueda de instrucciones. Luego entendimos que un programa no sólo podía modificar su entorno al ser ejecutado (otras celdas de memoria que no ocupen su código maquina, celdas de puertos, registros, etc) si no que también podría sobrescribir su código maquina (ya sea con ese propósito o sólo por un error conceptual), o bien, que el alumno debía tener la posibilidad de seguir ejecutando más allá del código máquina alojado en memoria o más. A partir de eso fue necesario corregir gran parte del modelo agregando una clase denominada \textbf{Intérprete}, cuya responsabilidad es interpretar la siguiente instrucción alojada en memoria para que luego sea ejecutada, otorgando más responsabilidad a la clase \textbf{Memoria} y descartando el objeto instancia de \textbf{Programa} una vez que éste es cargado en memoria con éxito.\\

Por otro lado, tuvieron que solicitarse extensiones al equipo de desarrolladores de Arena para poder implementar la interfaz del simulador utilizando dicho framework. Entre dichas extensiones podemos enumerar:

\begin{itemize}
\item \textbf{FileSelector}: que permite la carga de archivos de código fuente.
\item \textbf{CodeEditor} (O actualmente llamado KeywordTextArea): Es un área en la ventana donde se visualiza el el código fuente de los programas   una vez que han sido elegidos del navegador de archivos.
\item \textbf{Bindings} contra el background de componentes y celdas de una tabla, para permitir la visualización de cambios de colores en la memoria a partir de que se recorren las celdas del programa o se realiza algún cambio en el contenido de una celda.
\item \textbf{TexBox multiline} es un area de texto que puede navegarse (utilizando el \textit{scroll}) para ser utilizado como consola de devolución.
\item Icono para la aplicación, solo por cuestiones estéticas.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%55
\section{Casos de prueba}

En esta sección se describen los casos de prueba de la aplicación realizados para ilustrar el alcance de la aplicación y su robustez.

\subsection{Chequeo de sintaxis en la distintas Qi}

El chequeo de sintaxis de cada versión de la \textbf{Arquitectura Q} se lleva a cabo procesando algunos programas con el \textit{parser}, y con este objetivo se confeccionaron  dos casos de prueba por cada Qi:
\begin{enumerate}
\item \textbf{Chequear programa Qi válido}

Se utiliza como parámetro para el objeto de la clase \textbf{Parser} un programa Qi válido, es decir que es sintáticamente correcto en la arquitectura Qi, y éste comprobará la sintaxis del programa acorde a la arquitectura Qi seleccionada. Por ejemplo, un programa sintácticamente válido en Q6 puede no ser sintácticamente válido en Q1 si utiliza modos de direccionamiento o instrucciones que Q1 no incluye. Al terminar de chequear el programa, el objeto Parser retorna un objeto instancia de la clase Programa con la lista de instrucciones que fueron ensambladas. 
Se toma dicho resultado y como ultimo paso se compara con el programa esperado (que concuerda en objetos con el programa en código fuente escrito en el input).


\item \textbf{Chequear programa Qi es invalido} 

Se utiliza como parámetro para el objeto de la clase \textbf{Parser}  un programa Qi inválido, y el parser este comprobará la sintaxis del programa acorde a la arquitectura Qi seleccionada. Al terminar de chequear el programa, el objeto parser retorna un objeto de la clase Exception del tipo \textbf{SyntaxErrorException}, se captura la excepción y se toma de ella el mensaje de error para corroborar que sea el mensaje esperado (que describe la línea donde esta el error de sintáxis).

\end{enumerate}
\subsection{Ensamblado}

Para poder verificar que el ensamblado se realiza correctamente se toma un programa Qi y teniendo en cuenta que el resultado del parser genera un objeto de la clase \textbf{Programa} que contiene un conjunto de objetos de la clase \textbf{Instruccion}, además que cada instrucción tiene el comportamiento necesario para generar su propio \codmaq, se delega la generación del \codmaq a cada una, con la intención de comparar la secuencia resultante con la secuencia de \codmaq esperada.

\subsection{Decodificación}

El proceso de decodificación se verifica a la inversa del proceso de ensamblado: tomando como entrada una lista de cadenas que representa cada una al \codmaq\ de cada instrucción de un programa Qi. Esta lista se recorre para ser procesada por el objeto Interprete que es el encargado de Decodificar. Como resultado de este procesamiento se puede retornar una de dos cosas:
 
\begin{enumerate}
\item \textbf{Lista de Instrucciones} 

Este es el resultado de interpretar una secuencia de código máquina que representa correctamente a un conjunto de instrucciones y sus respectivos operandos. El objeto \textbf{Interprete} verifica los códigos de operación para poder crear las instrucciones correctamente, y luego, dependiendo de que tipo de instrucción se trate, comienza a interpretar sus respectivos operandos (si los tiene).
Por último se compara cada instrucción en la lista resultante con la lista que se esperaba.

\item\textbf{Error}

Al interpretar una secuencia de código máquina que no representa a ninguna instrucción (ya sea porque el código de operación o el código de algún modo de direccionamiento dentro del formato de cada instrucción es invalido) se obtiene una excepción del tipo \textbf{CodigoInvalidoException}.   
\end{enumerate}

\subsection{Ejecución}

Para verificar que la ejecución de un programa Qi se realiza correctamente fue necesario separar la verificación en los tres pasos del \ciclo:

\begin{itemize}
\item \textbf{Búsqueda} 

Para verificar la búsqueda de instrucción se toma la instrucción siguiente a ejecutar y se compara el valor que se guarda en el registro \IR con el valor esperado que debería tener (es decir, con el código maquina que representa a la instrucción siguiente a ejecutar). Ademas se verifica que el registro \PC\ tenga como valor la dirección de memoria de la siguiente instrucción a ejecutar, para corroborar esto se compara el \PC\ luego de la búsqueda con el resultado de la suma del \PC anterior y la cantidad de celdas que ocupa la instrucción procesada.

\item \textbf{Decodificación}

Para verificar la decodificación, se toma el valor que esta guardado registro \IR\ para que lo reciba el interprete que retornará el objeto instrucción interpretado a partir de ese valor. Al obtener dicha instrucción se compara con la instrucción esperada.
 
\item \textbf{Ejecución}

Para verificar el efecto de cada instrucción se preparó un caso de prueba por cada instrucción donde se tiene un estado inicial y un estado final esperado. Se realiza la ejecución de dicha instrucción y se compara el resultado obtenido (ya sea la modificación de flags, registros, celdas de memoria o puertos) con el resultado esperado. 

\end{itemize}

Las siguiente secciones son pasos que se realizan de acuerdo al efecto esperado de cada instrucción en el repertorio de la arquitectura \Q\ (detallada en el apéndice \ref{apendiceQ}).
  
\subsubsection{Operaciones de ALU}

La ALU es la encargada de ejecutar operaciones aritméticas y lógicas. Si la instrucción a ejecutar tiene un efecto aritmético/lógico se le delega la ejecución de la operación. Para poder verificar todas las operaciones creamos un caso de prueba por cada operación. Tanto las operaciones aritméticas como las lógicas se analizan de la misma forma:

\begin{enumerate}
\item Se toma cada valor de los operandos (la búsqueda se detalla el la siguiente sección)

\item Se realiza la operación aritmética/lógica. 

\item Se verifica el resultado obtenido con el resultado esperado.

\item Dado que algunas la mayoría de las operaciones modifica los flags, el valor final de éstos también se comparan con un resultado esperado. 
\end{enumerate}

\subsubsection{Búsqueda de Operandos}

Para verificar la búsqueda de operandos, se toma una instrucción cualquiera y se prueba todas las combinaciones de modos de direccionamiento para cada operando, teniendo en cuenta que son inválidas todas las combinaciones que tienen en el operando destino el modo de direccionamiento \textbf{Inmediato}. Se ejecuta entonces cada combinación para obtener el valor de cada operando, y este valor se lo compara con el valor esperado. 
 
\subsubsection{Almacenamiento de Operandos}

Para verificar el almacenamiento de operandos, se ejecuta cada una de las instrucciones de un programa Qi. Durante la etapa de ejecución, cada una tiene un operando destinado a guardar el resultado de su efecto, y luego de ese momento se puede comparar el valor final del operando con el valor esperado.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Ejemplos de uso}\label{erroresconceptuales}

Durante el desarrollo del simulador se encontraron situaciones especiales de uso que mostraron la potencialidad didáctica de la herramienta, según fue confirmado con los docentes de la materia \orga, dado que los estudiantes pueden experimentar mas allá de la resolución de problemas mediante programas \qi. En esta sección se muestran algunos ejemplos de estas situaciones.

\begin{enumerate}

\item En el siguiente programa \qi\ se ve que el uso de etiquetas permite enmascarar el modo de direccionamiento inmediato difiriendo la resolución de su valor al momento del ensamblado, ya que a partir de entonces es manejado como un valor constante, y por lo tanto puede asignarse a cualquier operando destino. En este ejemplo, la dirección inicial de la rutina \code{rutinaA} se almacena en la celda de memoria \code{0005}, para luego ser recuperada en el \code{CALL}

\begin{verbatim}
rutinaA:  ADD R0, 0x0002 
          ...
          MOV [0x0005], rutinaA
          CALL [0x0005] 
\end{verbatim}

\item En el siguiente ejemplo se puede ejercitar como el uso de subrutinas, puede alterar el \ciclo. En particular en el siguiente ejemplo, como efecto de la ejecución del \code{CALL} se apila la dirección de la siguiente instrucción (en este caso un \code{ADD}), y la ejecución del \code{RET} hace que se vuelva entonces a ejecutar esa misma instrucción y luego un \code{RET} que no tuvo su correspondiente \code{CALL}.

\begin{verbatim}
        CALL rutina 
rutina: ADD R0, 0x0002 
        RET 
\end{verbatim}

%Vamos a hacer un mapa del estado del registro SP antes de seguir: Antes de ejecutar el RET  el registro SP tiene el valor inicial que es FFEF, luego en la ejecución lo primero que se hace es incrementar el SP osea que ahora tiene el valor FFFO y luego buscar el valor de esa dirección para actualizar el registro PC. Para informarles la dirección FFFO es un puerto de E/S. La conclusión es que en esta instancia el flujo de ejecución del programa depende del valor que tiene ese puerto, puede pasar que el valor sea 0x0000 y se actualice el PC nos lleve al inicio de la memoria donde se encuentra inicializado otro programa y empiece a ejecutar desde allí. 


\item Dado el siguiente programa Qi:

\begin{verbatim}
ADD R0, [0x0002]
MUL R4, 0x0001
SUB [0x0003], 0x000A 
\end{verbatim}

Si el valor de PC hace referencia a la ultima instrucción (en este caso un \code{SUB}) y se lleva a cabo el \ciclo, como estado final se tiene el valor de PC apuntando a la siguiente instrucción a ejecutar. Como el programa no tiene mas instrucciones, si se continúa la simulación se comienza la búsqueda de una instrucción inválida.

\end{enumerate} 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Trabajo Futuro}

En esta sección se describirán características y funcionalidades que deseamos agregar al Simulador QSim en el futuro.

\begin{itemize}

\item Habilitar las instrucciones PUSH y POP.\\

Estas instrucciones permiten el manejo de la Pila como estructura de datos disponible para el programador. La instrucción \code{PUSH} tiene como efecto agregar el valor del operando origen a la pila, mientras que el \code{POP} permite sacar el primer elemento de la pila y guardarlo en el operando destino. Actualmente estas instrucciones se encuentran implementadas pero no habilitadas en ninguna gramática Qi.

\item Entrada y Salida\\

Es deseable que en el futuro el simulador admita la interacción con dispositivos de Entrada/Salida o con simuladores de estos últimos. Para esto habría que modelar buses de entrada hacia los puertos y dispositivos tales como el teclado, impresora, monitor que estén conectados a los puertos y un programa pueda detectar su cambios y utilizar sus datos como input para luego procesarlos en un programa.

\item Implementar interrupcciones\\

Para completar el módulo de entrada y salida sería necesario implementar también y agregar al modelo actual las interrupciones de entrada y salida, ya que de esta manera los dispositivos de entrada y salida pueden dar aviso a la cpu que hay nuevos datos para ser procesados.

\end{itemize}
